{"ast":null,"code":"import _slicedToArray from \"D:\\\\react\\\\project0330\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport React, { useRef } from 'react';\nimport { useSpring, animated, to } from '@react-spring/web';\nimport { useDrag } from '@use-gesture/react';\nimport { mergeProps } from '../../utils/with-default-props';\nimport { withNativeProps } from '../../utils/native-props';\nvar classPrefix = \"adm-floating-bubble\";\nvar defaultProps = {\n  axis: 'y'\n};\nexport var FloatingBubble = function FloatingBubble(p) {\n  var props = mergeProps(defaultProps, p);\n  var boundaryRef = useRef(null);\n  var buttonRef = useRef(null);\n  /**\n   * memoize the `to` function\n   * inside a component that renders frequently\n   * to prevent an unintended restart\n   */\n\n  var _useSpring = useSpring(function () {\n    return {\n      x: 0,\n      y: 0,\n      opacity: 1\n    };\n  }),\n      _useSpring2 = _slicedToArray(_useSpring, 2),\n      _useSpring2$ = _useSpring2[0],\n      x = _useSpring2$.x,\n      y = _useSpring2$.y,\n      opacity = _useSpring2$.opacity,\n      api = _useSpring2[1];\n\n  var bind = useDrag(function (state) {\n    var nextX = state.offset[0];\n    var nextY = state.offset[1];\n\n    if (state.last && props.magnetic) {\n      var boundary = boundaryRef.current;\n      var button = buttonRef.current;\n      if (!boundary || !button) return;\n      var boundaryRect = boundary.getBoundingClientRect();\n      var buttonRect = button.getBoundingClientRect();\n\n      if (props.magnetic === 'x') {\n        var compensation = x.goal - x.get();\n        var leftDistance = buttonRect.left + compensation - boundaryRect.left;\n        var rightDistance = boundaryRect.right - (buttonRect.right + compensation);\n\n        if (rightDistance <= leftDistance) {\n          nextX += rightDistance;\n        } else {\n          nextX -= leftDistance;\n        }\n      } else if (props.magnetic === 'y') {\n        var _compensation = y.goal - y.get();\n\n        var topDistance = buttonRect.top + _compensation - boundaryRect.top;\n        var bottomDistance = boundaryRect.bottom - (buttonRect.bottom + _compensation);\n\n        if (bottomDistance <= topDistance) {\n          nextY += bottomDistance;\n        } else {\n          nextY -= topDistance;\n        }\n      }\n    }\n\n    api.start({\n      x: nextX,\n      y: nextY\n    }); // active status\n\n    api.start({\n      opacity: state.active ? 0.8 : 1\n    });\n  }, {\n    axis: props.axis === 'xy' ? undefined : props.axis,\n    pointer: {\n      touch: true\n    },\n    // the component won't trigger drag logic if the user just clicked on the component.\n    filterTaps: true,\n    // set constraints to the user gesture\n    bounds: boundaryRef,\n    from: function from() {\n      return [x.get(), y.get()];\n    }\n  });\n  return withNativeProps(props, React.createElement(\"div\", {\n    className: classPrefix\n  }, React.createElement(\"div\", {\n    className: \"\".concat(classPrefix, \"-boundary-outer\")\n  }, React.createElement(\"div\", {\n    className: \"\".concat(classPrefix, \"-boundary\"),\n    ref: boundaryRef\n  })), React.createElement(animated.div, Object.assign({}, bind(), {\n    style: {\n      opacity: opacity,\n      transform: to([x, y], function (x, y) {\n        return \"translate(\".concat(x, \"px, \").concat(y, \"px)\");\n      })\n    },\n    onClick: props.onClick,\n    className: \"\".concat(classPrefix, \"-button\"),\n    ref: buttonRef\n  }), props.children)));\n};","map":null,"metadata":{},"sourceType":"module"}