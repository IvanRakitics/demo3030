{"ast":null,"code":"import _slicedToArray from \"D:\\\\react\\\\project0330\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport React, { forwardRef, useImperativeHandle, useRef } from 'react';\nimport { useDrag } from '@use-gesture/react';\nimport { useSpring, animated } from '@react-spring/web';\nimport { Slide } from './slide';\nimport { convertPx } from '../../utils/convert-px';\nimport { bound } from '../../utils/bound';\nvar classPrefix = \"adm-image-viewer\";\nexport var Slides = forwardRef(function (props, ref) {\n  var slideWidth = window.innerWidth + convertPx(16);\n\n  var _useSpring = useSpring(function () {\n    return {\n      x: props.defaultIndex * slideWidth,\n      config: {\n        tension: 250,\n        clamp: true\n      }\n    };\n  }),\n      _useSpring2 = _slicedToArray(_useSpring, 2),\n      x = _useSpring2[0].x,\n      api = _useSpring2[1];\n\n  var count = props.images.length;\n\n  function swipeTo(index) {\n    var immediate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    var _a;\n\n    var i = bound(index, 0, count - 1);\n    (_a = props.onIndexChange) === null || _a === void 0 ? void 0 : _a.call(props, i);\n    api.start({\n      x: i * slideWidth,\n      immediate: immediate\n    });\n  }\n\n  useImperativeHandle(ref, function () {\n    return {\n      swipeTo: swipeTo\n    };\n  });\n  var dragLockRef = useRef(false);\n  var bind = useDrag(function (state) {\n    if (dragLockRef.current) return;\n\n    var _state$offset = _slicedToArray(state.offset, 1),\n        offsetX = _state$offset[0];\n\n    if (state.last) {\n      var minIndex = Math.floor(offsetX / slideWidth);\n      var maxIndex = minIndex + 1;\n      var velocityOffset = Math.min(state.velocity[0] * 2000, slideWidth) * state.direction[0];\n      swipeTo(bound(Math.round((offsetX + velocityOffset) / slideWidth), minIndex, maxIndex));\n    } else {\n      api.start({\n        x: offsetX,\n        immediate: true\n      });\n    }\n  }, {\n    transform: function transform(_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n          x = _ref2[0],\n          y = _ref2[1];\n\n      return [-x, y];\n    },\n    from: function from() {\n      return [x.get(), 0];\n    },\n    bounds: function bounds() {\n      return {\n        left: 0,\n        right: (count - 1) * slideWidth\n      };\n    },\n    rubberband: true,\n    axis: 'x',\n    pointer: {\n      touch: true\n    }\n  });\n  return React.createElement(\"div\", Object.assign({\n    className: \"\".concat(classPrefix, \"-slides\")\n  }, bind()), React.createElement(animated.div, {\n    className: \"\".concat(classPrefix, \"-indicator\")\n  }, x.to(function (v) {\n    var index = bound(Math.round(v / slideWidth), 0, count - 1);\n    return \"\".concat(index + 1, \" / \").concat(count);\n  })), React.createElement(animated.div, {\n    className: \"\".concat(classPrefix, \"-slides-inner\"),\n    style: {\n      x: x.to(function (x) {\n        return -x;\n      })\n    }\n  }, props.images.map(function (image) {\n    return React.createElement(Slide, {\n      key: image,\n      image: image,\n      onTap: props.onTap,\n      maxZoom: props.maxZoom,\n      onZoomChange: function onZoomChange(zoom) {\n        if (zoom !== 1) {\n          var index = Math.round(x.get() / slideWidth);\n          api.start({\n            x: index * slideWidth\n          });\n        }\n      },\n      dragLockRef: dragLockRef\n    });\n  })));\n});","map":null,"metadata":{},"sourceType":"module"}