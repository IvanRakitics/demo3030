{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { mergeProps } from '../../utils/with-default-props';\nimport React, { useEffect, useRef, useState } from 'react';\nimport { useLockFn, useMemoizedFn } from 'ahooks';\nimport { withNativeProps } from '../../utils/native-props';\nimport { getScrollParent } from '../../utils/get-scroll-parent';\nimport DotLoading from '../dot-loading';\n\nfunction isWindow(element) {\n  return element === window;\n}\n\nconst classPrefix = `adm-infinite-scroll`;\n\nconst InfiniteScrollContent = _ref => {\n  let {\n    hasMore\n  } = _ref;\n  return React.createElement(React.Fragment, null, hasMore ? React.createElement(React.Fragment, null, React.createElement(\"span\", null, \"\\u52A0\\u8F7D\\u4E2D\"), React.createElement(DotLoading, null)) : React.createElement(\"span\", null, \"\\u6CA1\\u6709\\u66F4\\u591A\\u4E86\"));\n};\n\nexport const InfiniteScroll = p => {\n  const props = mergeProps({\n    threshold: 250\n  }, p);\n  const doLoadMore = useLockFn(() => props.loadMore());\n  const elementRef = useRef(null);\n  const [flag, setFlag] = useState({});\n  const nextFlagRef = useRef(flag);\n  const check = useMemoizedFn(() => __awaiter(void 0, void 0, void 0, function* () {\n    if (nextFlagRef.current !== flag) return;\n    if (!props.hasMore) return;\n    const element = elementRef.current;\n    if (!element) return;\n    if (!element.offsetParent) return;\n    const parent = getScrollParent(element);\n    if (!parent) return;\n    const rect = element.getBoundingClientRect();\n    const elementTop = rect.top;\n    const current = isWindow(parent) ? window.innerHeight : parent.getBoundingClientRect().bottom;\n\n    if (current >= elementTop - props.threshold) {\n      const nextFlag = {};\n      nextFlagRef.current = nextFlag;\n      yield doLoadMore();\n      setFlag(nextFlag);\n    }\n  })); // 确保在内容不足时会自动触发加载事件\n\n  useEffect(() => {\n    check();\n  });\n  useEffect(() => {\n    const element = elementRef.current;\n    if (!element) return;\n    const parent = getScrollParent(element);\n    if (!parent) return;\n\n    function onScroll() {\n      check();\n    }\n\n    parent.addEventListener('scroll', onScroll);\n    return () => {\n      parent.removeEventListener('scroll', onScroll);\n    };\n  }, []);\n  return withNativeProps(props, React.createElement(\"div\", {\n    className: classPrefix,\n    ref: elementRef\n  }, props.children && props.children, !props.children && React.createElement(InfiniteScrollContent, {\n    hasMore: props.hasMore\n  })));\n};","map":{"version":3,"sources":["D:/react/project0330/node_modules/antd-mobile/es/components/infinite-scroll/infinite-scroll.js"],"names":["__awaiter","mergeProps","React","useEffect","useRef","useState","useLockFn","useMemoizedFn","withNativeProps","getScrollParent","DotLoading","isWindow","element","window","classPrefix","InfiniteScrollContent","hasMore","createElement","Fragment","InfiniteScroll","p","props","threshold","doLoadMore","loadMore","elementRef","flag","setFlag","nextFlagRef","check","current","offsetParent","parent","rect","getBoundingClientRect","elementTop","top","innerHeight","bottom","nextFlag","onScroll","addEventListener","removeEventListener","className","ref","children"],"mappings":"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","sourcesContent":["import { __awaiter } from \"tslib\";\nimport { mergeProps } from '../../utils/with-default-props';\nimport React, { useEffect, useRef, useState } from 'react';\nimport { useLockFn, useMemoizedFn } from 'ahooks';\nimport { withNativeProps } from '../../utils/native-props';\nimport { getScrollParent } from '../../utils/get-scroll-parent';\nimport DotLoading from '../dot-loading';\n\nfunction isWindow(element) {\n  return element === window;\n}\n\nconst classPrefix = `adm-infinite-scroll`;\n\nconst InfiniteScrollContent = ({\n  hasMore\n}) => {\n  return React.createElement(React.Fragment, null, hasMore ? React.createElement(React.Fragment, null, React.createElement(\"span\", null, \"\\u52A0\\u8F7D\\u4E2D\"), React.createElement(DotLoading, null)) : React.createElement(\"span\", null, \"\\u6CA1\\u6709\\u66F4\\u591A\\u4E86\"));\n};\n\nexport const InfiniteScroll = p => {\n  const props = mergeProps({\n    threshold: 250\n  }, p);\n  const doLoadMore = useLockFn(() => props.loadMore());\n  const elementRef = useRef(null);\n  const [flag, setFlag] = useState({});\n  const nextFlagRef = useRef(flag);\n  const check = useMemoizedFn(() => __awaiter(void 0, void 0, void 0, function* () {\n    if (nextFlagRef.current !== flag) return;\n    if (!props.hasMore) return;\n    const element = elementRef.current;\n    if (!element) return;\n    if (!element.offsetParent) return;\n    const parent = getScrollParent(element);\n    if (!parent) return;\n    const rect = element.getBoundingClientRect();\n    const elementTop = rect.top;\n    const current = isWindow(parent) ? window.innerHeight : parent.getBoundingClientRect().bottom;\n\n    if (current >= elementTop - props.threshold) {\n      const nextFlag = {};\n      nextFlagRef.current = nextFlag;\n      yield doLoadMore();\n      setFlag(nextFlag);\n    }\n  })); // 确保在内容不足时会自动触发加载事件\n\n  useEffect(() => {\n    check();\n  });\n  useEffect(() => {\n    const element = elementRef.current;\n    if (!element) return;\n    const parent = getScrollParent(element);\n    if (!parent) return;\n\n    function onScroll() {\n      check();\n    }\n\n    parent.addEventListener('scroll', onScroll);\n    return () => {\n      parent.removeEventListener('scroll', onScroll);\n    };\n  }, []);\n  return withNativeProps(props, React.createElement(\"div\", {\n    className: classPrefix,\n    ref: elementRef\n  }, props.children && props.children, !props.children && React.createElement(InfiniteScrollContent, {\n    hasMore: props.hasMore\n  })));\n};"]},"metadata":{},"sourceType":"module"}