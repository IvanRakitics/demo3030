{"ast":null,"code":"import React, { forwardRef, useEffect, useImperativeHandle, useMemo, useRef, useState } from 'react';\nimport { withNativeProps } from '../../utils/native-props';\nimport { mergeProps } from '../../utils/with-default-props';\nimport classNames from 'classnames';\nimport { SwiperItem } from './swiper-item';\nimport { devWarning } from '../../utils/dev-log';\nimport { useSpring, animated } from '@react-spring/web';\nimport { useDrag } from '@use-gesture/react';\nimport PageIndicator from '../page-indicator';\nimport { staged } from 'staged-components';\nimport { useRefState } from '../../utils/use-ref-state';\nimport { bound } from '../../utils/bound';\nimport { useIsomorphicLayoutEffect, useUpdateEffect } from 'ahooks';\nconst defaultProps = {\n  defaultIndex: 0,\n  allowTouchMove: true,\n  autoplay: false,\n  autoplayInterval: 3000,\n  loop: false,\n  direction: 'horizontal',\n  slideSize: 100,\n  trackOffset: 0,\n  stuckAtBoundary: true,\n  rubberband: true\n};\nexport const Swiper = forwardRef(staged((p, ref) => {\n  const props = mergeProps(defaultProps, p);\n  const isVertical = props.direction === 'vertical';\n  const slideRatio = props.slideSize / 100;\n  const offsetRatio = props.trackOffset / 100;\n  const {\n    validChildren,\n    count\n  } = useMemo(() => {\n    let count = 0;\n    const validChildren = React.Children.map(props.children, child => {\n      if (!React.isValidElement(child)) return null;\n\n      if (child.type !== SwiperItem) {\n        devWarning('Swiper', 'The children of `Swiper` must be `Swiper.Item` components.');\n        return null;\n      }\n\n      count++;\n      return child;\n    });\n    return {\n      validChildren,\n      count\n    };\n  }, [props.children]);\n\n  if (count === 0 || !validChildren) {\n    devWarning('Swiper', '`Swiper` needs at least one child.');\n    return null;\n  }\n\n  return () => {\n    let loop = props.loop;\n\n    if (slideRatio * (count - 1) < 1) {\n      loop = false;\n    }\n\n    const trackRef = useRef(null);\n\n    function getSlidePixels() {\n      const track = trackRef.current;\n      if (!track) return 0;\n      const trackPixels = isVertical ? track.offsetHeight : track.offsetWidth;\n      return trackPixels * props.slideSize / 100;\n    }\n\n    const [current, setCurrent] = useState(props.defaultIndex);\n    useUpdateEffect(() => {\n      var _a;\n\n      (_a = props.onIndexChange) === null || _a === void 0 ? void 0 : _a.call(props, current);\n    }, [current]);\n    const [dragging, setDragging, draggingRef] = useRefState(false);\n\n    function boundIndex(current) {\n      let min = 0;\n      let max = count - 1;\n\n      if (props.stuckAtBoundary) {\n        min += offsetRatio / slideRatio;\n        max -= (1 - slideRatio - offsetRatio) / slideRatio;\n      }\n\n      return bound(current, min, max);\n    }\n\n    const [{\n      position\n    }, api] = useSpring(() => ({\n      position: boundIndex(current) * 100,\n      config: {\n        tension: 200,\n        friction: 30\n      },\n      onRest: () => {\n        if (draggingRef.current) return;\n        const rawX = position.get();\n        const totalWidth = 100 * count;\n        const standardPosition = modulus(rawX, totalWidth);\n        if (standardPosition === rawX) return;\n        api.start({\n          position: standardPosition,\n          immediate: true\n        });\n      }\n    }), [count]);\n    const bind = useDrag(state => {\n      const slidePixels = getSlidePixels();\n      if (!slidePixels) return;\n      const paramIndex = isVertical ? 1 : 0;\n      const offset = state.offset[paramIndex];\n      const direction = state.direction[paramIndex];\n      const velocity = state.velocity[paramIndex];\n      setDragging(true);\n\n      if (!state.last) {\n        api.start({\n          position: offset * 100 / slidePixels,\n          immediate: true\n        });\n      } else {\n        const minIndex = Math.floor(offset / slidePixels);\n        const maxIndex = minIndex + 1;\n        const index = Math.round((offset + velocity * 2000 * direction) / slidePixels);\n        swipeTo(bound(index, minIndex, maxIndex));\n        window.setTimeout(() => {\n          setDragging(false);\n        });\n      }\n    }, {\n      transform: _ref => {\n        let [x, y] = _ref;\n        return [-x, -y];\n      },\n      from: () => {\n        const slidePixels = getSlidePixels();\n        return [position.get() / 100 * slidePixels, position.get() / 100 * slidePixels];\n      },\n      bounds: () => {\n        if (loop) return {};\n        const slidePixels = getSlidePixels();\n        const lowerBound = boundIndex(0) * slidePixels;\n        const upperBound = boundIndex(count - 1) * slidePixels;\n        return isVertical ? {\n          top: lowerBound,\n          bottom: upperBound\n        } : {\n          left: lowerBound,\n          right: upperBound\n        };\n      },\n      rubberband: props.rubberband,\n      axis: isVertical ? 'y' : 'x',\n      preventScroll: !isVertical,\n      pointer: {\n        touch: true\n      }\n    });\n\n    function swipeTo(index) {\n      let immediate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      const roundedIndex = Math.round(index);\n      const targetIndex = loop ? modulus(roundedIndex, count) : bound(roundedIndex, 0, count - 1);\n      setCurrent(targetIndex);\n      api.start({\n        position: (loop ? roundedIndex : boundIndex(roundedIndex)) * 100,\n        immediate\n      });\n    }\n\n    function swipeNext() {\n      swipeTo(Math.round(position.get() / 100) + 1);\n    }\n\n    function swipePrev() {\n      swipeTo(Math.round(position.get() / 100) - 1);\n    }\n\n    useImperativeHandle(ref, () => ({\n      swipeTo,\n      swipeNext,\n      swipePrev\n    }));\n    useIsomorphicLayoutEffect(() => {\n      const maxIndex = validChildren.length - 1;\n\n      if (current > maxIndex) {\n        swipeTo(maxIndex, true);\n      }\n    });\n    const {\n      autoplay,\n      autoplayInterval\n    } = props;\n    useEffect(() => {\n      if (!autoplay || dragging) return;\n      const interval = window.setInterval(() => {\n        swipeNext();\n      }, autoplayInterval);\n      return () => {\n        window.clearInterval(interval);\n      };\n    }, [autoplay, autoplayInterval, dragging]);\n\n    function renderTrackInner() {\n      if (loop) {\n        return React.createElement(\"div\", {\n          className: 'adm-swiper-track-inner'\n        }, React.Children.map(validChildren, (child, index) => {\n          return React.createElement(animated.div, {\n            className: 'adm-swiper-slide',\n            style: {\n              [isVertical ? 'y' : 'x']: position.to(position => {\n                let finalPosition = -position + index * 100;\n                const totalWidth = count * 100;\n                const flagWidth = totalWidth / 2;\n                finalPosition = modulus(finalPosition + flagWidth, totalWidth) - flagWidth;\n                return `${finalPosition}%`;\n              }),\n              [isVertical ? 'top' : 'left']: `-${index * 100}%`\n            }\n          }, child);\n        }));\n      } else {\n        return React.createElement(animated.div, {\n          className: 'adm-swiper-track-inner',\n          style: {\n            [isVertical ? 'y' : 'x']: position.to(position => `${-position}%`)\n          }\n        }, React.Children.map(validChildren, child => {\n          return React.createElement(\"div\", {\n            className: 'adm-swiper-slide'\n          }, child);\n        }));\n      }\n    }\n\n    const style = {\n      '--slide-size': `${props.slideSize}%`,\n      '--track-offset': `${props.trackOffset}%`\n    };\n    return withNativeProps(props, React.createElement(\"div\", {\n      className: classNames('adm-swiper', `adm-swiper-${props.direction}`),\n      style: style\n    }, React.createElement(\"div\", Object.assign({\n      ref: trackRef,\n      className: classNames('adm-swiper-track', {\n        'adm-swiper-track-allow-touch-move': props.allowTouchMove\n      }),\n      onClickCapture: e => {\n        if (draggingRef.current) {\n          e.stopPropagation();\n        }\n      }\n    }, props.allowTouchMove ? bind() : {}), renderTrackInner()), props.indicator === undefined ? React.createElement(\"div\", {\n      className: 'adm-swiper-indicator'\n    }, React.createElement(PageIndicator, Object.assign({}, props.indicatorProps, {\n      total: count,\n      current: current,\n      direction: props.direction\n    }))) : props.indicator(count, current)));\n  };\n}));\n\nfunction modulus(value, division) {\n  const remainder = value % division;\n  return remainder < 0 ? remainder + division : remainder;\n}","map":{"version":3,"sources":["D:/react/project0330/node_modules/antd-mobile/es/components/swiper/swiper.js"],"names":["React","forwardRef","useEffect","useImperativeHandle","useMemo","useRef","useState","withNativeProps","mergeProps","classNames","SwiperItem","devWarning","useSpring","animated","useDrag","PageIndicator","staged","useRefState","bound","useIsomorphicLayoutEffect","useUpdateEffect","defaultProps","defaultIndex","allowTouchMove","autoplay","autoplayInterval","loop","direction","slideSize","trackOffset","stuckAtBoundary","rubberband","Swiper","p","ref","props","isVertical","slideRatio","offsetRatio","validChildren","count","Children","map","children","child","isValidElement","type","trackRef","getSlidePixels","track","current","trackPixels","offsetHeight","offsetWidth","setCurrent","_a","onIndexChange","call","dragging","setDragging","draggingRef","boundIndex","min","max","position","api","config","tension","friction","onRest","rawX","get","totalWidth","standardPosition","modulus","start","immediate","bind","state","slidePixels","paramIndex","offset","velocity","last","minIndex","Math","floor","maxIndex","index","round","swipeTo","window","setTimeout","transform","x","y","from","bounds","lowerBound","upperBound","top","bottom","left","right","axis","preventScroll","pointer","touch","roundedIndex","targetIndex","swipeNext","swipePrev","length","interval","setInterval","clearInterval","renderTrackInner","createElement","className","div","style","to","finalPosition","flagWidth","Object","assign","onClickCapture","e","stopPropagation","indicator","undefined","indicatorProps","total","value","division","remainder"],"mappings":"AAAA,OAAOA,KAAP,IAAgBC,UAAhB,EAA4BC,SAA5B,EAAuCC,mBAAvC,EAA4DC,OAA5D,EAAqEC,MAArE,EAA6EC,QAA7E,QAA6F,OAA7F;AACA,SAASC,eAAT,QAAgC,0BAAhC;AACA,SAASC,UAAT,QAA2B,gCAA3B;AACA,OAAOC,UAAP,MAAuB,YAAvB;AACA,SAASC,UAAT,QAA2B,eAA3B;AACA,SAASC,UAAT,QAA2B,qBAA3B;AACA,SAASC,SAAT,EAAoBC,QAApB,QAAoC,mBAApC;AACA,SAASC,OAAT,QAAwB,oBAAxB;AACA,OAAOC,aAAP,MAA0B,mBAA1B;AACA,SAASC,MAAT,QAAuB,mBAAvB;AACA,SAASC,WAAT,QAA4B,2BAA5B;AACA,SAASC,KAAT,QAAsB,mBAAtB;AACA,SAASC,yBAAT,EAAoCC,eAApC,QAA2D,QAA3D;AACA,MAAMC,YAAY,GAAG;AACnBC,EAAAA,YAAY,EAAE,CADK;AAEnBC,EAAAA,cAAc,EAAE,IAFG;AAGnBC,EAAAA,QAAQ,EAAE,KAHS;AAInBC,EAAAA,gBAAgB,EAAE,IAJC;AAKnBC,EAAAA,IAAI,EAAE,KALa;AAMnBC,EAAAA,SAAS,EAAE,YANQ;AAOnBC,EAAAA,SAAS,EAAE,GAPQ;AAQnBC,EAAAA,WAAW,EAAE,CARM;AASnBC,EAAAA,eAAe,EAAE,IATE;AAUnBC,EAAAA,UAAU,EAAE;AAVO,CAArB;AAYA,OAAO,MAAMC,MAAM,GAAG/B,UAAU,CAACe,MAAM,CAAC,CAACiB,CAAD,EAAIC,GAAJ,KAAY;AAClD,QAAMC,KAAK,GAAG3B,UAAU,CAACa,YAAD,EAAeY,CAAf,CAAxB;AACA,QAAMG,UAAU,GAAGD,KAAK,CAACR,SAAN,KAAoB,UAAvC;AACA,QAAMU,UAAU,GAAGF,KAAK,CAACP,SAAN,GAAkB,GAArC;AACA,QAAMU,WAAW,GAAGH,KAAK,CAACN,WAAN,GAAoB,GAAxC;AACA,QAAM;AACJU,IAAAA,aADI;AAEJC,IAAAA;AAFI,MAGFpC,OAAO,CAAC,MAAM;AAChB,QAAIoC,KAAK,GAAG,CAAZ;AACA,UAAMD,aAAa,GAAGvC,KAAK,CAACyC,QAAN,CAAeC,GAAf,CAAmBP,KAAK,CAACQ,QAAzB,EAAmCC,KAAK,IAAI;AAChE,UAAI,CAAC5C,KAAK,CAAC6C,cAAN,CAAqBD,KAArB,CAAL,EAAkC,OAAO,IAAP;;AAElC,UAAIA,KAAK,CAACE,IAAN,KAAepC,UAAnB,EAA+B;AAC7BC,QAAAA,UAAU,CAAC,QAAD,EAAW,4DAAX,CAAV;AACA,eAAO,IAAP;AACD;;AAED6B,MAAAA,KAAK;AACL,aAAOI,KAAP;AACD,KAVqB,CAAtB;AAWA,WAAO;AACLL,MAAAA,aADK;AAELC,MAAAA;AAFK,KAAP;AAID,GAjBU,EAiBR,CAACL,KAAK,CAACQ,QAAP,CAjBQ,CAHX;;AAsBA,MAAIH,KAAK,KAAK,CAAV,IAAe,CAACD,aAApB,EAAmC;AACjC5B,IAAAA,UAAU,CAAC,QAAD,EAAW,oCAAX,CAAV;AACA,WAAO,IAAP;AACD;;AAED,SAAO,MAAM;AACX,QAAIe,IAAI,GAAGS,KAAK,CAACT,IAAjB;;AAEA,QAAIW,UAAU,IAAIG,KAAK,GAAG,CAAZ,CAAV,GAA2B,CAA/B,EAAkC;AAChCd,MAAAA,IAAI,GAAG,KAAP;AACD;;AAED,UAAMqB,QAAQ,GAAG1C,MAAM,CAAC,IAAD,CAAvB;;AAEA,aAAS2C,cAAT,GAA0B;AACxB,YAAMC,KAAK,GAAGF,QAAQ,CAACG,OAAvB;AACA,UAAI,CAACD,KAAL,EAAY,OAAO,CAAP;AACZ,YAAME,WAAW,GAAGf,UAAU,GAAGa,KAAK,CAACG,YAAT,GAAwBH,KAAK,CAACI,WAA5D;AACA,aAAOF,WAAW,GAAGhB,KAAK,CAACP,SAApB,GAAgC,GAAvC;AACD;;AAED,UAAM,CAACsB,OAAD,EAAUI,UAAV,IAAwBhD,QAAQ,CAAC6B,KAAK,CAACb,YAAP,CAAtC;AACAF,IAAAA,eAAe,CAAC,MAAM;AACpB,UAAImC,EAAJ;;AAEA,OAACA,EAAE,GAAGpB,KAAK,CAACqB,aAAZ,MAA+B,IAA/B,IAAuCD,EAAE,KAAK,KAAK,CAAnD,GAAuD,KAAK,CAA5D,GAAgEA,EAAE,CAACE,IAAH,CAAQtB,KAAR,EAAee,OAAf,CAAhE;AACD,KAJc,EAIZ,CAACA,OAAD,CAJY,CAAf;AAKA,UAAM,CAACQ,QAAD,EAAWC,WAAX,EAAwBC,WAAxB,IAAuC3C,WAAW,CAAC,KAAD,CAAxD;;AAEA,aAAS4C,UAAT,CAAoBX,OAApB,EAA6B;AAC3B,UAAIY,GAAG,GAAG,CAAV;AACA,UAAIC,GAAG,GAAGvB,KAAK,GAAG,CAAlB;;AAEA,UAAIL,KAAK,CAACL,eAAV,EAA2B;AACzBgC,QAAAA,GAAG,IAAIxB,WAAW,GAAGD,UAArB;AACA0B,QAAAA,GAAG,IAAI,CAAC,IAAI1B,UAAJ,GAAiBC,WAAlB,IAAiCD,UAAxC;AACD;;AAED,aAAOnB,KAAK,CAACgC,OAAD,EAAUY,GAAV,EAAeC,GAAf,CAAZ;AACD;;AAED,UAAM,CAAC;AACLC,MAAAA;AADK,KAAD,EAEHC,GAFG,IAEIrD,SAAS,CAAC,OAAO;AACzBoD,MAAAA,QAAQ,EAAEH,UAAU,CAACX,OAAD,CAAV,GAAsB,GADP;AAEzBgB,MAAAA,MAAM,EAAE;AACNC,QAAAA,OAAO,EAAE,GADH;AAENC,QAAAA,QAAQ,EAAE;AAFJ,OAFiB;AAMzBC,MAAAA,MAAM,EAAE,MAAM;AACZ,YAAIT,WAAW,CAACV,OAAhB,EAAyB;AACzB,cAAMoB,IAAI,GAAGN,QAAQ,CAACO,GAAT,EAAb;AACA,cAAMC,UAAU,GAAG,MAAMhC,KAAzB;AACA,cAAMiC,gBAAgB,GAAGC,OAAO,CAACJ,IAAD,EAAOE,UAAP,CAAhC;AACA,YAAIC,gBAAgB,KAAKH,IAAzB,EAA+B;AAC/BL,QAAAA,GAAG,CAACU,KAAJ,CAAU;AACRX,UAAAA,QAAQ,EAAES,gBADF;AAERG,UAAAA,SAAS,EAAE;AAFH,SAAV;AAID;AAhBwB,KAAP,CAAD,EAiBf,CAACpC,KAAD,CAjBe,CAFnB;AAoBA,UAAMqC,IAAI,GAAG/D,OAAO,CAACgE,KAAK,IAAI;AAC5B,YAAMC,WAAW,GAAG/B,cAAc,EAAlC;AACA,UAAI,CAAC+B,WAAL,EAAkB;AAClB,YAAMC,UAAU,GAAG5C,UAAU,GAAG,CAAH,GAAO,CAApC;AACA,YAAM6C,MAAM,GAAGH,KAAK,CAACG,MAAN,CAAaD,UAAb,CAAf;AACA,YAAMrD,SAAS,GAAGmD,KAAK,CAACnD,SAAN,CAAgBqD,UAAhB,CAAlB;AACA,YAAME,QAAQ,GAAGJ,KAAK,CAACI,QAAN,CAAeF,UAAf,CAAjB;AACArB,MAAAA,WAAW,CAAC,IAAD,CAAX;;AAEA,UAAI,CAACmB,KAAK,CAACK,IAAX,EAAiB;AACflB,QAAAA,GAAG,CAACU,KAAJ,CAAU;AACRX,UAAAA,QAAQ,EAAEiB,MAAM,GAAG,GAAT,GAAeF,WADjB;AAERH,UAAAA,SAAS,EAAE;AAFH,SAAV;AAID,OALD,MAKO;AACL,cAAMQ,QAAQ,GAAGC,IAAI,CAACC,KAAL,CAAWL,MAAM,GAAGF,WAApB,CAAjB;AACA,cAAMQ,QAAQ,GAAGH,QAAQ,GAAG,CAA5B;AACA,cAAMI,KAAK,GAAGH,IAAI,CAACI,KAAL,CAAW,CAACR,MAAM,GAAGC,QAAQ,GAAG,IAAX,GAAkBvD,SAA5B,IAAyCoD,WAApD,CAAd;AACAW,QAAAA,OAAO,CAACxE,KAAK,CAACsE,KAAD,EAAQJ,QAAR,EAAkBG,QAAlB,CAAN,CAAP;AACAI,QAAAA,MAAM,CAACC,UAAP,CAAkB,MAAM;AACtBjC,UAAAA,WAAW,CAAC,KAAD,CAAX;AACD,SAFD;AAGD;AACF,KAvBmB,EAuBjB;AACDkC,MAAAA,SAAS,EAAE;AAAA,YAAC,CAACC,CAAD,EAAIC,CAAJ,CAAD;AAAA,eAAY,CAAC,CAACD,CAAF,EAAK,CAACC,CAAN,CAAZ;AAAA,OADV;AAEDC,MAAAA,IAAI,EAAE,MAAM;AACV,cAAMjB,WAAW,GAAG/B,cAAc,EAAlC;AACA,eAAO,CAACgB,QAAQ,CAACO,GAAT,KAAiB,GAAjB,GAAuBQ,WAAxB,EAAqCf,QAAQ,CAACO,GAAT,KAAiB,GAAjB,GAAuBQ,WAA5D,CAAP;AACD,OALA;AAMDkB,MAAAA,MAAM,EAAE,MAAM;AACZ,YAAIvE,IAAJ,EAAU,OAAO,EAAP;AACV,cAAMqD,WAAW,GAAG/B,cAAc,EAAlC;AACA,cAAMkD,UAAU,GAAGrC,UAAU,CAAC,CAAD,CAAV,GAAgBkB,WAAnC;AACA,cAAMoB,UAAU,GAAGtC,UAAU,CAACrB,KAAK,GAAG,CAAT,CAAV,GAAwBuC,WAA3C;AACA,eAAO3C,UAAU,GAAG;AAClBgE,UAAAA,GAAG,EAAEF,UADa;AAElBG,UAAAA,MAAM,EAAEF;AAFU,SAAH,GAGb;AACFG,UAAAA,IAAI,EAAEJ,UADJ;AAEFK,UAAAA,KAAK,EAAEJ;AAFL,SAHJ;AAOD,OAlBA;AAmBDpE,MAAAA,UAAU,EAAEI,KAAK,CAACJ,UAnBjB;AAoBDyE,MAAAA,IAAI,EAAEpE,UAAU,GAAG,GAAH,GAAS,GApBxB;AAqBDqE,MAAAA,aAAa,EAAE,CAACrE,UArBf;AAsBDsE,MAAAA,OAAO,EAAE;AACPC,QAAAA,KAAK,EAAE;AADA;AAtBR,KAvBiB,CAApB;;AAkDA,aAASjB,OAAT,CAAiBF,KAAjB,EAA2C;AAAA,UAAnBZ,SAAmB,uEAAP,KAAO;AACzC,YAAMgC,YAAY,GAAGvB,IAAI,CAACI,KAAL,CAAWD,KAAX,CAArB;AACA,YAAMqB,WAAW,GAAGnF,IAAI,GAAGgD,OAAO,CAACkC,YAAD,EAAepE,KAAf,CAAV,GAAkCtB,KAAK,CAAC0F,YAAD,EAAe,CAAf,EAAkBpE,KAAK,GAAG,CAA1B,CAA/D;AACAc,MAAAA,UAAU,CAACuD,WAAD,CAAV;AACA5C,MAAAA,GAAG,CAACU,KAAJ,CAAU;AACRX,QAAAA,QAAQ,EAAE,CAACtC,IAAI,GAAGkF,YAAH,GAAkB/C,UAAU,CAAC+C,YAAD,CAAjC,IAAmD,GADrD;AAERhC,QAAAA;AAFQ,OAAV;AAID;;AAED,aAASkC,SAAT,GAAqB;AACnBpB,MAAAA,OAAO,CAACL,IAAI,CAACI,KAAL,CAAWzB,QAAQ,CAACO,GAAT,KAAiB,GAA5B,IAAmC,CAApC,CAAP;AACD;;AAED,aAASwC,SAAT,GAAqB;AACnBrB,MAAAA,OAAO,CAACL,IAAI,CAACI,KAAL,CAAWzB,QAAQ,CAACO,GAAT,KAAiB,GAA5B,IAAmC,CAApC,CAAP;AACD;;AAEDpE,IAAAA,mBAAmB,CAAC+B,GAAD,EAAM,OAAO;AAC9BwD,MAAAA,OAD8B;AAE9BoB,MAAAA,SAF8B;AAG9BC,MAAAA;AAH8B,KAAP,CAAN,CAAnB;AAKA5F,IAAAA,yBAAyB,CAAC,MAAM;AAC9B,YAAMoE,QAAQ,GAAGhD,aAAa,CAACyE,MAAd,GAAuB,CAAxC;;AAEA,UAAI9D,OAAO,GAAGqC,QAAd,EAAwB;AACtBG,QAAAA,OAAO,CAACH,QAAD,EAAW,IAAX,CAAP;AACD;AACF,KANwB,CAAzB;AAOA,UAAM;AACJ/D,MAAAA,QADI;AAEJC,MAAAA;AAFI,QAGFU,KAHJ;AAIAjC,IAAAA,SAAS,CAAC,MAAM;AACd,UAAI,CAACsB,QAAD,IAAakC,QAAjB,EAA2B;AAC3B,YAAMuD,QAAQ,GAAGtB,MAAM,CAACuB,WAAP,CAAmB,MAAM;AACxCJ,QAAAA,SAAS;AACV,OAFgB,EAEdrF,gBAFc,CAAjB;AAGA,aAAO,MAAM;AACXkE,QAAAA,MAAM,CAACwB,aAAP,CAAqBF,QAArB;AACD,OAFD;AAGD,KARQ,EAQN,CAACzF,QAAD,EAAWC,gBAAX,EAA6BiC,QAA7B,CARM,CAAT;;AAUA,aAAS0D,gBAAT,GAA4B;AAC1B,UAAI1F,IAAJ,EAAU;AACR,eAAO1B,KAAK,CAACqH,aAAN,CAAoB,KAApB,EAA2B;AAChCC,UAAAA,SAAS,EAAE;AADqB,SAA3B,EAEJtH,KAAK,CAACyC,QAAN,CAAeC,GAAf,CAAmBH,aAAnB,EAAkC,CAACK,KAAD,EAAQ4C,KAAR,KAAkB;AACrD,iBAAOxF,KAAK,CAACqH,aAAN,CAAoBxG,QAAQ,CAAC0G,GAA7B,EAAkC;AACvCD,YAAAA,SAAS,EAAE,kBAD4B;AAEvCE,YAAAA,KAAK,EAAE;AACL,eAACpF,UAAU,GAAG,GAAH,GAAS,GAApB,GAA0B4B,QAAQ,CAACyD,EAAT,CAAYzD,QAAQ,IAAI;AAChD,oBAAI0D,aAAa,GAAG,CAAC1D,QAAD,GAAYwB,KAAK,GAAG,GAAxC;AACA,sBAAMhB,UAAU,GAAGhC,KAAK,GAAG,GAA3B;AACA,sBAAMmF,SAAS,GAAGnD,UAAU,GAAG,CAA/B;AACAkD,gBAAAA,aAAa,GAAGhD,OAAO,CAACgD,aAAa,GAAGC,SAAjB,EAA4BnD,UAA5B,CAAP,GAAiDmD,SAAjE;AACA,uBAAQ,GAAED,aAAc,GAAxB;AACD,eANyB,CADrB;AAQL,eAACtF,UAAU,GAAG,KAAH,GAAW,MAAtB,GAAgC,IAAGoD,KAAK,GAAG,GAAI;AAR1C;AAFgC,WAAlC,EAYJ5C,KAZI,CAAP;AAaD,SAdE,CAFI,CAAP;AAiBD,OAlBD,MAkBO;AACL,eAAO5C,KAAK,CAACqH,aAAN,CAAoBxG,QAAQ,CAAC0G,GAA7B,EAAkC;AACvCD,UAAAA,SAAS,EAAE,wBAD4B;AAEvCE,UAAAA,KAAK,EAAE;AACL,aAACpF,UAAU,GAAG,GAAH,GAAS,GAApB,GAA0B4B,QAAQ,CAACyD,EAAT,CAAYzD,QAAQ,IAAK,GAAE,CAACA,QAAS,GAArC;AADrB;AAFgC,SAAlC,EAKJhE,KAAK,CAACyC,QAAN,CAAeC,GAAf,CAAmBH,aAAnB,EAAkCK,KAAK,IAAI;AAC5C,iBAAO5C,KAAK,CAACqH,aAAN,CAAoB,KAApB,EAA2B;AAChCC,YAAAA,SAAS,EAAE;AADqB,WAA3B,EAEJ1E,KAFI,CAAP;AAGD,SAJE,CALI,CAAP;AAUD;AACF;;AAED,UAAM4E,KAAK,GAAG;AACZ,sBAAiB,GAAErF,KAAK,CAACP,SAAU,GADvB;AAEZ,wBAAmB,GAAEO,KAAK,CAACN,WAAY;AAF3B,KAAd;AAIA,WAAOtB,eAAe,CAAC4B,KAAD,EAAQnC,KAAK,CAACqH,aAAN,CAAoB,KAApB,EAA2B;AACvDC,MAAAA,SAAS,EAAE7G,UAAU,CAAC,YAAD,EAAgB,cAAa0B,KAAK,CAACR,SAAU,EAA7C,CADkC;AAEvD6F,MAAAA,KAAK,EAAEA;AAFgD,KAA3B,EAG3BxH,KAAK,CAACqH,aAAN,CAAoB,KAApB,EAA2BO,MAAM,CAACC,MAAP,CAAc;AAC1C3F,MAAAA,GAAG,EAAEa,QADqC;AAE1CuE,MAAAA,SAAS,EAAE7G,UAAU,CAAC,kBAAD,EAAqB;AACxC,6CAAqC0B,KAAK,CAACZ;AADH,OAArB,CAFqB;AAK1CuG,MAAAA,cAAc,EAAEC,CAAC,IAAI;AACnB,YAAInE,WAAW,CAACV,OAAhB,EAAyB;AACvB6E,UAAAA,CAAC,CAACC,eAAF;AACD;AACF;AATyC,KAAd,EAU3B7F,KAAK,CAACZ,cAAN,GAAuBsD,IAAI,EAA3B,GAAgC,EAVL,CAA3B,EAUqCuC,gBAAgB,EAVrD,CAH2B,EAa+BjF,KAAK,CAAC8F,SAAN,KAAoBC,SAApB,GAAgClI,KAAK,CAACqH,aAAN,CAAoB,KAApB,EAA2B;AACtHC,MAAAA,SAAS,EAAE;AAD2G,KAA3B,EAE1FtH,KAAK,CAACqH,aAAN,CAAoBtG,aAApB,EAAmC6G,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB1F,KAAK,CAACgG,cAAxB,EAAwC;AAC5EC,MAAAA,KAAK,EAAE5F,KADqE;AAE5EU,MAAAA,OAAO,EAAEA,OAFmE;AAG5EvB,MAAAA,SAAS,EAAEQ,KAAK,CAACR;AAH2D,KAAxC,CAAnC,CAF0F,CAAhC,GAMtDQ,KAAK,CAAC8F,SAAN,CAAgBzF,KAAhB,EAAuBU,OAAvB,CAnBuB,CAAR,CAAtB;AAoBD,GA/MD;AAgND,CAhPsC,CAAP,CAAzB;;AAkPP,SAASwB,OAAT,CAAiB2D,KAAjB,EAAwBC,QAAxB,EAAkC;AAChC,QAAMC,SAAS,GAAGF,KAAK,GAAGC,QAA1B;AACA,SAAOC,SAAS,GAAG,CAAZ,GAAgBA,SAAS,GAAGD,QAA5B,GAAuCC,SAA9C;AACD","sourcesContent":["import React, { forwardRef, useEffect, useImperativeHandle, useMemo, useRef, useState } from 'react';\nimport { withNativeProps } from '../../utils/native-props';\nimport { mergeProps } from '../../utils/with-default-props';\nimport classNames from 'classnames';\nimport { SwiperItem } from './swiper-item';\nimport { devWarning } from '../../utils/dev-log';\nimport { useSpring, animated } from '@react-spring/web';\nimport { useDrag } from '@use-gesture/react';\nimport PageIndicator from '../page-indicator';\nimport { staged } from 'staged-components';\nimport { useRefState } from '../../utils/use-ref-state';\nimport { bound } from '../../utils/bound';\nimport { useIsomorphicLayoutEffect, useUpdateEffect } from 'ahooks';\nconst defaultProps = {\n  defaultIndex: 0,\n  allowTouchMove: true,\n  autoplay: false,\n  autoplayInterval: 3000,\n  loop: false,\n  direction: 'horizontal',\n  slideSize: 100,\n  trackOffset: 0,\n  stuckAtBoundary: true,\n  rubberband: true\n};\nexport const Swiper = forwardRef(staged((p, ref) => {\n  const props = mergeProps(defaultProps, p);\n  const isVertical = props.direction === 'vertical';\n  const slideRatio = props.slideSize / 100;\n  const offsetRatio = props.trackOffset / 100;\n  const {\n    validChildren,\n    count\n  } = useMemo(() => {\n    let count = 0;\n    const validChildren = React.Children.map(props.children, child => {\n      if (!React.isValidElement(child)) return null;\n\n      if (child.type !== SwiperItem) {\n        devWarning('Swiper', 'The children of `Swiper` must be `Swiper.Item` components.');\n        return null;\n      }\n\n      count++;\n      return child;\n    });\n    return {\n      validChildren,\n      count\n    };\n  }, [props.children]);\n\n  if (count === 0 || !validChildren) {\n    devWarning('Swiper', '`Swiper` needs at least one child.');\n    return null;\n  }\n\n  return () => {\n    let loop = props.loop;\n\n    if (slideRatio * (count - 1) < 1) {\n      loop = false;\n    }\n\n    const trackRef = useRef(null);\n\n    function getSlidePixels() {\n      const track = trackRef.current;\n      if (!track) return 0;\n      const trackPixels = isVertical ? track.offsetHeight : track.offsetWidth;\n      return trackPixels * props.slideSize / 100;\n    }\n\n    const [current, setCurrent] = useState(props.defaultIndex);\n    useUpdateEffect(() => {\n      var _a;\n\n      (_a = props.onIndexChange) === null || _a === void 0 ? void 0 : _a.call(props, current);\n    }, [current]);\n    const [dragging, setDragging, draggingRef] = useRefState(false);\n\n    function boundIndex(current) {\n      let min = 0;\n      let max = count - 1;\n\n      if (props.stuckAtBoundary) {\n        min += offsetRatio / slideRatio;\n        max -= (1 - slideRatio - offsetRatio) / slideRatio;\n      }\n\n      return bound(current, min, max);\n    }\n\n    const [{\n      position\n    }, api] = useSpring(() => ({\n      position: boundIndex(current) * 100,\n      config: {\n        tension: 200,\n        friction: 30\n      },\n      onRest: () => {\n        if (draggingRef.current) return;\n        const rawX = position.get();\n        const totalWidth = 100 * count;\n        const standardPosition = modulus(rawX, totalWidth);\n        if (standardPosition === rawX) return;\n        api.start({\n          position: standardPosition,\n          immediate: true\n        });\n      }\n    }), [count]);\n    const bind = useDrag(state => {\n      const slidePixels = getSlidePixels();\n      if (!slidePixels) return;\n      const paramIndex = isVertical ? 1 : 0;\n      const offset = state.offset[paramIndex];\n      const direction = state.direction[paramIndex];\n      const velocity = state.velocity[paramIndex];\n      setDragging(true);\n\n      if (!state.last) {\n        api.start({\n          position: offset * 100 / slidePixels,\n          immediate: true\n        });\n      } else {\n        const minIndex = Math.floor(offset / slidePixels);\n        const maxIndex = minIndex + 1;\n        const index = Math.round((offset + velocity * 2000 * direction) / slidePixels);\n        swipeTo(bound(index, minIndex, maxIndex));\n        window.setTimeout(() => {\n          setDragging(false);\n        });\n      }\n    }, {\n      transform: ([x, y]) => [-x, -y],\n      from: () => {\n        const slidePixels = getSlidePixels();\n        return [position.get() / 100 * slidePixels, position.get() / 100 * slidePixels];\n      },\n      bounds: () => {\n        if (loop) return {};\n        const slidePixels = getSlidePixels();\n        const lowerBound = boundIndex(0) * slidePixels;\n        const upperBound = boundIndex(count - 1) * slidePixels;\n        return isVertical ? {\n          top: lowerBound,\n          bottom: upperBound\n        } : {\n          left: lowerBound,\n          right: upperBound\n        };\n      },\n      rubberband: props.rubberband,\n      axis: isVertical ? 'y' : 'x',\n      preventScroll: !isVertical,\n      pointer: {\n        touch: true\n      }\n    });\n\n    function swipeTo(index, immediate = false) {\n      const roundedIndex = Math.round(index);\n      const targetIndex = loop ? modulus(roundedIndex, count) : bound(roundedIndex, 0, count - 1);\n      setCurrent(targetIndex);\n      api.start({\n        position: (loop ? roundedIndex : boundIndex(roundedIndex)) * 100,\n        immediate\n      });\n    }\n\n    function swipeNext() {\n      swipeTo(Math.round(position.get() / 100) + 1);\n    }\n\n    function swipePrev() {\n      swipeTo(Math.round(position.get() / 100) - 1);\n    }\n\n    useImperativeHandle(ref, () => ({\n      swipeTo,\n      swipeNext,\n      swipePrev\n    }));\n    useIsomorphicLayoutEffect(() => {\n      const maxIndex = validChildren.length - 1;\n\n      if (current > maxIndex) {\n        swipeTo(maxIndex, true);\n      }\n    });\n    const {\n      autoplay,\n      autoplayInterval\n    } = props;\n    useEffect(() => {\n      if (!autoplay || dragging) return;\n      const interval = window.setInterval(() => {\n        swipeNext();\n      }, autoplayInterval);\n      return () => {\n        window.clearInterval(interval);\n      };\n    }, [autoplay, autoplayInterval, dragging]);\n\n    function renderTrackInner() {\n      if (loop) {\n        return React.createElement(\"div\", {\n          className: 'adm-swiper-track-inner'\n        }, React.Children.map(validChildren, (child, index) => {\n          return React.createElement(animated.div, {\n            className: 'adm-swiper-slide',\n            style: {\n              [isVertical ? 'y' : 'x']: position.to(position => {\n                let finalPosition = -position + index * 100;\n                const totalWidth = count * 100;\n                const flagWidth = totalWidth / 2;\n                finalPosition = modulus(finalPosition + flagWidth, totalWidth) - flagWidth;\n                return `${finalPosition}%`;\n              }),\n              [isVertical ? 'top' : 'left']: `-${index * 100}%`\n            }\n          }, child);\n        }));\n      } else {\n        return React.createElement(animated.div, {\n          className: 'adm-swiper-track-inner',\n          style: {\n            [isVertical ? 'y' : 'x']: position.to(position => `${-position}%`)\n          }\n        }, React.Children.map(validChildren, child => {\n          return React.createElement(\"div\", {\n            className: 'adm-swiper-slide'\n          }, child);\n        }));\n      }\n    }\n\n    const style = {\n      '--slide-size': `${props.slideSize}%`,\n      '--track-offset': `${props.trackOffset}%`\n    };\n    return withNativeProps(props, React.createElement(\"div\", {\n      className: classNames('adm-swiper', `adm-swiper-${props.direction}`),\n      style: style\n    }, React.createElement(\"div\", Object.assign({\n      ref: trackRef,\n      className: classNames('adm-swiper-track', {\n        'adm-swiper-track-allow-touch-move': props.allowTouchMove\n      }),\n      onClickCapture: e => {\n        if (draggingRef.current) {\n          e.stopPropagation();\n        }\n      }\n    }, props.allowTouchMove ? bind() : {}), renderTrackInner()), props.indicator === undefined ? React.createElement(\"div\", {\n      className: 'adm-swiper-indicator'\n    }, React.createElement(PageIndicator, Object.assign({}, props.indicatorProps, {\n      total: count,\n      current: current,\n      direction: props.direction\n    }))) : props.indicator(count, current)));\n  };\n}));\n\nfunction modulus(value, division) {\n  const remainder = value % division;\n  return remainder < 0 ? remainder + division : remainder;\n}"]},"metadata":{},"sourceType":"module"}